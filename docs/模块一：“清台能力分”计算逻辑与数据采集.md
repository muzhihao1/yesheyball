## 模块一：“清台能力分”计算逻辑与数据采集

**任务目标**：为“清台能力分”的五个维度（准度、杆法、走位、发力、策略）设计具体的计算公式和数据采集点，以便在应用中实现。

### 1.1 核心设计：训练单元的数据采集

为了实现能力分的计算，我们需要对“训练单元”（Training Unit）的数据结构进行扩展。在 `training_units` 表（或你存储训练内容的地方）的 `metadata` 字段中，为每个训练单元增加以下属性：

```json
{
  "unit_type": "practice", // 'theory', 'practice', 'challenge'
  "primary_skill": "accuracy", // 关联的能力维度: 'accuracy', 'spin', 'positioning', 'power', 'strategy'
  "difficulty": "medium", // 'easy', 'medium', 'hard'
  "max_attempts": 10, // 本次练习的总尝试次数
  "scoring_method": "success_rate" // 'success_rate', 'completion'
}
```

当用户完成一次训练后，后端需要记录一份详细的训练日志 `training_logs`。

### 1.2 五大能力维度计分公式

每个维度的分数都是一个 0-100 的值，存储在 `users` 表中。每次训练后，只更新与本次训练 `primary_skill` 相关的维度分数。

#### 1. 准度分 (Accuracy Score)

- **数据来源**：所有 `primary_skill` 为 `accuracy` 的训练单元。
- **计算逻辑**：基于**加权移动平均成功率**。
- **所需用户字段**：`accuracy_total_shots`, `accuracy_successful_shots`
- **公式**：
  1.  当用户完成一次准度训练后，记录本次的 `new_successful_shots` 和 `new_total_shots`。
  2.  更新用户总记录：
      `user.accuracy_total_shots += new_total_shots`
      `user.accuracy_successful_shots += new_successful_shots`
  3.  计算新的准度分：
      `user.accuracy_score = (user.accuracy_successful_shots / user.accuracy_total_shots) * 100`

#### 2. 杆法分 (Spin Control Score)

- **数据来源**：所有 `primary_skill` 为 `spin` 的训练单元。
- **计算逻辑**：基于**加权完成度**，高难度训练权重更高。
- **所需用户字段**：`spin_total_difficulty_points`, `spin_completed_difficulty_points`
- **难度权重**：`easy: 1`, `medium: 2`, `hard: 3`
- **公式**：
  1.  当用户完成一次杆法训练后，获取该训练的 `difficulty` 和 `is_completed` (true/false)。
  2.  计算本次训练的难度分：`difficulty_points = weight[difficulty]`
  3.  更新用户总记录：
      `user.spin_total_difficulty_points += difficulty_points`
      `if (is_completed) { user.spin_completed_difficulty_points += difficulty_points }`
  4.  计算新的杆法分：
      `user.spin_score = (user.spin_completed_difficulty_points / user.spin_total_difficulty_points) * 100`

#### 3. 走位分 (Positioning Score)

- **数据来源**：所有 `primary_skill` 为 `positioning` 的训练单元。
- **计算逻辑**：与“杆法分”完全相同，使用加权完成度。
- **所需用户字段**：`positioning_total_difficulty_points`, `positioning_completed_difficulty_points`
- **公式**：
  `user.positioning_score = (user.positioning_completed_difficulty_points / user.positioning_total_difficulty_points) * 100`

#### 4. 发力分 (Power Control Score)

- **数据来源**：所有 `primary_skill` 为 `power` 的训练单元。
- **计算逻辑**：与“杆法分”完全相同，使用加权完成度。
- **所需用户字段**：`power_total_difficulty_points`, `power_completed_difficulty_points`
- **公式**：
  `user.power_score = (user.power_completed_difficulty_points / user.power_total_difficulty_points) * 100`

#### 5. 策略分 (Strategy Score) - (初期简化版)

- **数据来源**：所有 `primary_skill` 为 `strategy` 的训练单元，以及每周的“能力评估挑战”。
- **计算逻辑**：初期同样使用加权完成度。
- **所需用户字段**：`strategy_total_difficulty_points`, `strategy_completed_difficulty_points`
- **公式**：
  `user.strategy_score = (user.strategy_completed_difficulty_points / user.strategy_total_difficulty_points) * 100`

### 1.3 “清台能力分”总分计算

在更新完任何一个维度的分数后，都需要重新计算用户的总分。

- **所需用户字段**：`clearance_score`
- **公式**：
  `clearance_score = (accuracy_score * 0.3) + (spin_score * 0.25) + (positioning_score * 0.2) + (power_score * 0.15) + (strategy_score * 0.1)`

### ✅ 验收标准

- [ ] `training_units` 的 `metadata` 字段已添加 `primary_skill`, `difficulty`, `scoring_method` 等属性。
- [ ] `users` 表中已添加 `accuracy_score`, `spin_score`, `positioning_score`, `power_score`, `strategy_score`, `clearance_score` 以及用于计算的累计字段。
- [ ] 完成一次准度训练后，用户的 `accuracy_score` 和 `clearance_score` 会更新。
- [ ] 完成一次高难度杆法训练后，用户的 `spin_score` 和 `clearance_score` 会更新，且分数增加幅度大于完成低难度训练。
## 模块二：数据库改造方案

**任务目标**：修改现有数据库结构，增加支持“90天挑战”和“清台能力分”计算所需的表和字段。

### 2.1 `users` 表扩展

**任务**：在 `users` 表中添加与挑战状态和能力分数相关的字段。

**Drizzle ORM Schema (`src/db/schema.ts`)**
```typescript
// ... in your users table definition
export const users = pgTable('users', {
  // ... existing fields
  
  // Challenge Status
  challengeStatus: varchar('challenge_status', { length: 20 }).default('not_started'), // 'not_started', 'in_progress', 'completed'
  challengeStartDate: timestamp('challenge_start_date'),
  challengeCurrentDay: integer('challenge_current_day').default(0),

  // Clearance Score
  clearanceScore: real('clearance_score').default(0),

  // Skill Scores (0-100)
  accuracyScore: real('accuracy_score').default(0),
  spinScore: real('spin_score').default(0),
  positioningScore: real('positioning_score').default(0),
  powerScore: real('power_score').default(0),
  strategyScore: real('strategy_score').default(0),

  // Raw data for score calculation
  accuracyTotalShots: integer('accuracy_total_shots').default(0),
  accuracySuccessfulShots: integer('accuracy_successful_shots').default(0),
  
  spinTotalDifficultyPoints: integer('spin_total_difficulty_points').default(0),
  spinCompletedDifficultyPoints: integer('spin_completed_difficulty_points').default(0),

  positioningTotalDifficultyPoints: integer('positioning_total_difficulty_points').default(0),
  positioningCompletedDifficultyPoints: integer('positioning_completed_difficulty_points').default(0),

  powerTotalDifficultyPoints: integer('power_total_difficulty_points').default(0),
  powerCompletedDifficultyPoints: integer('power_completed_difficulty_points').default(0),

  strategyTotalDifficultyPoints: integer('strategy_total_difficulty_points').default(0),
  strategyCompletedDifficultyPoints: integer('strategy_completed_difficulty_points').default(0),
});
```

### 2.2 新增 `challenge_timeline` 表

**任务**：创建一个新表，用于存储预设的90天主线训练计划。

**Drizzle ORM Schema (`src/db/schema.ts`)**
```typescript
// ... add new table
export const challengeTimeline = pgTable('challenge_timeline', {
  day: integer('day').primaryKey(), // 1 to 90
  trainingUnitId: varchar('training_unit_id', { length: 50 }).notNull(),
  title: varchar('title', { length: 100 }),
  description: text('description'),
});
```

### 2.3 新增 `training_logs` 表

**任务**：创建一个新表，用于记录用户的每一次训练，这是能力分计算的数据基础。

**Drizzle ORM Schema (`src/db/schema.ts`)**
```typescript
// ... add new table
import { serial, boolean, real } from 'drizzle-orm/pg-core';

export const trainingLogs = pgTable('training_logs', {
  id: serial('id').primaryKey(),
  userId: varchar('user_id').notNull().references(() => users.id),
  trainingUnitId: varchar('training_unit_id', { length: 50 }).notNull(),
  completedAt: timestamp('completed_at').defaultNow(),
  isCompleted: boolean('is_completed').default(false),
  
  // For 'success_rate' scoring
  successfulAttempts: integer('successful_attempts'),
  totalAttempts: integer('total_attempts'),

  // Score changes
  clearanceScoreChange: real('clearance_score_change'),
});
```

### 2.4 数据库迁移

保存 schema 文件后，请执行 Drizzle ORM 的迁移命令，将新的表和字段应用到你的 PostgreSQL 数据库中。

```bash
pnpm drizzle-kit generate:pg
pnpm drizzle-kit push:pg
```

### ✅ 验收标准

- [ ] `users` 表中已成功添加 `challengeStatus`, `clearanceScore` 等所有新字段。
- [ ] `challenge_timeline` 和 `training_logs` 两个新表已成功创建在数据库中。
- [ ] 数据库表结构与 Drizzle ORM schema 定义完全匹配。
## 模块三：后端 API 开发

**任务目标**：创建支持“90天挑战”功能所需的核心 API 端点。

### 3.1 开始挑战

- **端点**: `POST /api/challenge/start`
- **逻辑**:
  1.  验证用户是否已登录。
  2.  检查用户的 `challengeStatus` 是否为 `not_started`。
  3.  更新用户的 `challengeStatus` 为 `in_progress`，`challengeStartDate` 为当前时间，`challengeCurrentDay` 为 1。
  4.  返回成功消息。

### 3.2 获取今日挑战信息

- **端点**: `GET /api/challenge/today`
- **逻辑**:
  1.  验证用户是否已登录且 `challengeStatus` 为 `in_progress`。
  2.  根据用户的 `challengeCurrentDay` 从 `challenge_timeline` 表中获取今日的主线任务。
  3.  根据用户的能力分数（例如 `accuracy_score` 等），找到分数最低的维度。
  4.  从 `training_plans` 表中为该最低维度随机选择一个“入门”或“进阶”难度的训练计划作为推荐任务。
  5.  返回一个包含主线任务和推荐任务的 JSON 对象。

### 3.3 完成训练并更新能力分

- **端点**: `POST /api/training/complete`
- **请求体 (Body)**:
  ```json
  {
    "trainingUnitId": "skill_1_1_practice",
    "isCompleted": true,
    "successfulAttempts": 8,
    "totalAttempts": 10
  }
  ```
- **逻辑 (核心)**:
  1.  验证用户是否已登录。
  2.  根据 `trainingUnitId` 获取训练单元的 `metadata`（`primary_skill`, `difficulty` 等）。
  3.  **计算分数变化**：根据模块一中定义的公式，计算本次训练对相应能力维度分数的贡献。
  4.  **更新用户分数**：在数据库事务中，更新用户的维度分数（例如 `accuracy_score`）和累计数据（例如 `accuracy_total_shots`）。
  5.  **重新计算总分**：更新用户的 `clearance_score`。
  6.  **记录日志**：在 `training_logs` 表中插入一条新的训练记录，包含分数变化等信息。
  7.  返回本次训练后的即时反馈信息，包括分数变化、更新后的总分等。

### 3.4 获取挑战仪表盘数据

- **端点**: `GET /api/challenge/dashboard`
- **逻辑**:
  1.  验证用户是否已登录。
  2.  获取用户的挑战状态信息（`challengeStatus`, `challengeCurrentDay`）。
  3.  获取用户的“清台能力分”成长历史（可以从 `training_logs` 中聚合）。
  4.  获取用户的训练日历（可以从 `training_logs` 中按日期分组）。
  5.  将所有数据组合成一个大的 JSON 对象返回，供前端仪表盘页面使用。

### ✅ 验收标准

- [ ] 调用 `POST /api/challenge/start` 后，用户的 `challengeStatus` 变为 `in_progress`。
- [ ] 调用 `GET /api/challenge/today`，可以获取到包含主线任务和推荐任务的数据。
- [ ] 调用 `POST /api/training/complete` 后，用户的能力分数和总分会正确更新，并且 `training_logs` 表中会新增一条记录。
- [ ] 调用 `GET /api/challenge/dashboard`，可以一次性获取到渲染仪表盘所需的全部数据。
## 模块四：前端 UI 改造

**任务目标**：将现有的“训练计划”页面改造为“90天挑战”专属仪表盘，并实现相关交互逻辑。

### 4.1 页面路由改造

- **任务**：将 `/tasks` 路由重定向到 `/challenge`，并将“训练计划”的导航链接指向 `/challenge`。
- **逻辑**：创建一个新的页面组件 `ChallengeDashboardPage.tsx`，并将其与 `/challenge` 路由关联。

### 4.2 “90天挑战”仪表盘页面 (`ChallengeDashboardPage.tsx`)

**任务**：根据UI设计方案，开发仪表盘页面。

- **数据获取**：使用 TanStack Query 的 `useQuery` 调用 `GET /api/challenge/dashboard` API，获取渲染页面所需的全部数据。
- **组件拆分**：将仪表盘拆分为多个子组件，以保持代码清晰：
    - `ChallengeProgress.tsx`：核心进度模块（环形进度条）。
    - `TodayTask.tsx`：今日任务模块。
    - `ScoreChart.tsx`：能力成长模块（折线图）。
    - `TrainingCalendar.tsx`：训练日历模块。
    - `ResourceLinks.tsx`：资源入口模块。

### 4.3 核心交互流程

1.  **加入挑战**：
    - 如果 `dashboard` API 返回的用户 `challengeStatus` 为 `not_started`，则显示一个“接受挑战”的模态框。
    - 用户点击“接受挑战”后，调用 `POST /api/challenge/start` API，并在成功后刷新仪表盘数据。

2.  **完成训练**：
    - 当用户在训练界面点击“完成训练”时，调用 `POST /api/training/complete` API，并传递训练结果。
    - API 返回成功后，显示一个全屏的、动画效果丰富的“训练报告”组件，展示分数变化。
    - 关闭报告后，自动跳转回仪表盘页面，此时仪表盘上的数据应已更新。

### 4.4 关键组件实现提示

- **环形进度条 (`ChallengeProgress.tsx`)**：可以使用 `recharts` 或 `framer-motion` 等库来实现动画效果。
- **能力成长折线图 (`ScoreChart.tsx`)**：强烈推荐使用 `recharts` 库，它可以轻松实现漂亮的折线图。
- **训练日历 (`TrainingCalendar.tsx`)**：可以使用 `react-day-picker` 或 `react-calendar` 等成熟的日历组件库作为基础进行定制。

### ✅ 验收标准

- [ ] 首次登录的用户会看到“接受挑战”的邀请。
- [ ] 接受挑战后，页面显示为“90天挑战”仪表盘，包含所有设计的模块。
- [ ] “今日任务”模块能正确显示主线任务和推荐任务。
- [ ] “能力成长”模块能正确绘制用户的“清台能力分”历史曲线。
- [ ] “训练日历”能正确标记已完成和未完成的日期。
- [ ] 完成一次训练后，会显示动画效果的训练报告，并且仪表盘数据会自动刷新后仪表盘数据会自动刷新。
